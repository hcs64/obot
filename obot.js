// Generated by CoffeeScript 1.7.1
(function() {
  var DOWN, LEFT, RIGHT, UP, addCommandButtonAction, animateLevel, arrowButtonRender, arrowCommandRender, bot_points, bot_size, bot_speed, cell_size, clear, clickControlPanel, command_scrim_points, command_size, commands_per_row, cont_cnv, cont_ctx, control_bevel, control_panel, control_size, controls_start, down_arrow_cmd, empty_cmd, go_down_button, go_left_button, go_right_button, go_up_button, hr3, inner_command_size, inner_control_size, left_arrow_cmd, lerp, levelAnimMode, levelMode, level_cnv, level_ctx, level_state, moveCommand, noActionCommand, playButtonAction, play_button, prog_cnv, prog_ctx, render, renderArrow, renderBot, renderButtonScrim, renderCommand, renderControlPanel, renderLevel, renderPlayButton, renderUndoButton, resetAndRunLevel, resetLevel, right_arrow_cmd, rr3, setupControlPanel, setupLevel, stepLevelSimulation, stop, undoButtonAction, undo_button, up_arrow_cmd;

  level_cnv = document.getElementById('level');

  prog_cnv = document.getElementById('program');

  cont_cnv = document.getElementById('controls');

  level_ctx = level_cnv.getContext('2d');

  prog_ctx = prog_cnv.getContext('2d');

  cont_ctx = cont_cnv.getContext('2d');

  clear = function(cnv, ctx) {
    ctx.fillStyle = 'black';
    return ctx.fillRect(0, 0, cnv.width, cnv.height);
  };

  cell_size = 32;

  renderLevel = function(level_ctx, prog_ctx) {
    var cmd, col, ctx, i, row, xi, yi, _i, _j, _k, _len, _ref;
    ctx = level_ctx;
    ctx.save();
    ctx.lineWidth = .5;
    ctx.strokeStyle = 'white';
    for (xi = _i = 1; _i < 10; xi = ++_i) {
      ctx.beginPath();
      ctx.moveTo(xi * 32 + .5, 0);
      ctx.lineTo(xi * 32 + .5, 320);
      ctx.stroke();
    }
    for (yi = _j = 1; _j < 10; yi = ++_j) {
      ctx.beginPath();
      ctx.moveTo(0, yi * 32 + .5);
      ctx.lineTo(320, yi * 32 + .5);
      ctx.stroke();
    }
    ctx.restore();
    this.bot.render(ctx);
    ctx = prog_ctx;
    _ref = this.commands;
    for (i = _k = 0, _len = _ref.length; _k < _len; i = ++_k) {
      cmd = _ref[i];
      row = Math.floor(i / commands_per_row);
      col = i % commands_per_row;
      renderCommand(ctx, cmd, {
        x: col * command_size,
        y: row * command_size
      }, (this.show_current_command != null) && i === this.show_current_command);
    }
    if (this.show_current_command !== null && this.show_current_command >= this.commands.length) {
      row = Math.floor(this.commands.length / commands_per_row);
      col = this.commands.length % commands_per_row;
      renderCommand(ctx, empty_cmd, {
        x: col * command_size,
        y: row * command_size
      }, true);
    }
  };

  hr3 = Math.sqrt(3) / 2;

  rr3 = 1 / Math.sqrt(3);

  bot_size = cell_size * .75;

  bot_speed = 4;

  bot_points = [
    {
      x: bot_size * rr3,
      y: 0
    }, {
      x: -bot_size * (hr3 - rr3),
      y: -bot_size / 2
    }, {
      x: -bot_size * (hr3 - rr3),
      y: bot_size / 2
    }
  ];

  renderBot = function(ctx) {
    var bp;
    bp = bot_points;
    ctx.save();
    ctx.translate((this.showxi + .5) * cell_size, (this.showyi + .5) * cell_size);
    ctx.rotate(-this.showdir);
    ctx.beginPath();
    ctx.moveTo(bp[0].x, bp[0].y);
    ctx.lineTo(bp[1].x, bp[1].y);
    ctx.lineTo(bp[2].x, bp[2].y);
    ctx.closePath();
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = 'white';
    ctx.fillStyle = 'black';
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(bot_points[0].x, bot_points[0].y, bot_size / 4, (1 - 1 / 5) * Math.PI, (1 + 1 / 5) * Math.PI);
    ctx.stroke();
    ctx.restore();
  };

  UP = {
    theta: Math.PI / 2,
    dx: 0,
    dy: -1
  };

  LEFT = {
    theta: Math.PI,
    dx: -1,
    dy: 0
  };

  RIGHT = {
    theta: 0,
    dx: 1,
    dy: 0
  };

  DOWN = {
    theta: -Math.PI / 2,
    dx: 0,
    dy: 1
  };

  renderArrow = function(ctx, dir, size) {
    var ahs, as;
    as = size * .75;
    ahs = size * .2;
    ctx.rotate(-dir);
    ctx.beginPath();
    ctx.moveTo(-as / 2, 0);
    ctx.lineTo(as / 2, 0);
    ctx.lineTo(as / 2 - ahs, ahs);
    ctx.moveTo(as / 2, 0);
    ctx.lineTo(as / 2 - ahs, -ahs);
    ctx.stroke();
  };

  command_size = 38;

  inner_command_size = 29;

  commands_per_row = 8;

  command_scrim_points = (function() {
    var ics;
    ics = inner_command_size;
    return [
      {
        x: -ics / 2,
        y: -ics / 2
      }, {
        x: -ics / 2,
        y: +ics / 2
      }, {
        x: +ics / 2,
        y: +ics / 2
      }, {
        x: +ics / 2,
        y: -ics / 2
      }
    ];
  })();

  renderCommand = function(ctx, what, where, current) {
    var cs, ics, pt, _i, _len;
    if (current == null) {
      current = false;
    }
    cs = command_size;
    ics = inner_command_size;
    ctx.save();
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = 'white';
    ctx.translate(where.x + .5 * cs, where.y + .5 * cs);
    ctx.strokeRect(-ics / 2, -ics / 2, ics, ics);
    if (current) {
      ctx.fillStyle = 'white';
      for (_i = 0, _len = command_scrim_points.length; _i < _len; _i++) {
        pt = command_scrim_points[_i];
        ctx.fillRect(pt.x - ics * .1, pt.y - ics * .1, ics * .2, ics * .2);
      }
    }
    what.render(ctx);
    ctx.restore();
  };

  controls_start = {
    x: 10,
    y: 10
  };

  control_size = 66;

  inner_control_size = 60;

  control_bevel = 6;

  renderControlPanel = function(ctx) {
    var b, i, _i, _len, _ref;
    ctx.translate(controls_start.x, controls_start.y);
    _ref = this.buttons;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      b = _ref[i];
      ctx.save();
      ctx.lineWidth = 1.5;
      if (i !== this.selected_button) {
        ctx.strokeStyle = 'white';
        ctx.fillStyle = 'black';
      } else {
        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'white';
      }
      renderButtonScrim(ctx);
      ctx.translate(inner_control_size / 2, inner_control_size / 2);
      b.render(ctx);
      ctx.restore();
      ctx.translate(0, control_size);
    }
  };

  clickControlPanel = function(clickpos) {
    var b, i, x, y, _i, _len, _ref;
    x = controls_start.x;
    y = controls_start.y;
    _ref = this.buttons;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      b = _ref[i];
      if (clickpos.x > x && clickpos.y > y && clickpos.x < x + control_size && clickpos.y < y + control_size) {
        return [b, i];
      }
      y = y + control_size;
    }
    return [null, -1];
  };

  renderButtonScrim = function(ctx) {
    var cb, ics;
    ctx.save();
    ics = inner_control_size;
    cb = control_bevel;
    ctx.beginPath();
    ctx.moveTo(0, cb);
    ctx.lineTo(cb, 0);
    ctx.lineTo(ics - cb, 0);
    ctx.lineTo(ics, cb);
    ctx.lineTo(ics, ics - cb);
    ctx.lineTo(ics - cb, ics);
    ctx.lineTo(cb, ics);
    ctx.lineTo(0, ics - cb);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  };

  renderPlayButton = function(ctx) {
    var bp;
    bp = bot_points;
    ctx.beginPath();
    ctx.moveTo(bp[0].x, bp[0].y);
    ctx.lineTo(bp[1].x, bp[1].y);
    ctx.lineTo(bp[2].x, bp[2].y);
    ctx.closePath();
    ctx.stroke();
  };

  renderUndoButton = function(ctx) {
    var ics;
    ics = inner_control_size * .35;
    ctx.beginPath();
    ctx.moveTo(-ics, -ics);
    ctx.lineTo(ics, ics);
    ctx.moveTo(-ics, ics);
    ctx.lineTo(ics, -ics);
    ctx.stroke();
  };

  moveCommand = function(level) {
    level.bot.xi += this.dir.dx;
    level.bot.yi += this.dir.dy;
    return level.bot.dir = this.dir.theta;
  };

  noActionCommand = function(level) {};

  arrowCommandRender = function(ctx) {
    return renderArrow(ctx, this.dir.theta, inner_command_size);
  };

  up_arrow_cmd = {
    render: arrowCommandRender,
    dir: UP,
    action: moveCommand
  };

  left_arrow_cmd = {
    render: arrowCommandRender,
    dir: LEFT,
    action: moveCommand
  };

  right_arrow_cmd = {
    render: arrowCommandRender,
    dir: RIGHT,
    action: moveCommand
  };

  down_arrow_cmd = {
    render: arrowCommandRender,
    dir: DOWN,
    action: moveCommand
  };

  empty_cmd = {
    render: function() {},
    action: noActionCommand
  };

  addCommandButtonAction = function(level) {
    switch (level.mode) {
      case levelMode.STOPPED:
        level.commands[level.current_command] = this.cmd;
        level.advanceCurrentCommand();
        break;
      case levelMode.PLAYING:
        level.commands[level.commands.length] = this.cmd;
    }
  };

  playButtonAction = function(level) {
    level.resetAndRun();
  };

  undoButtonAction = function(level) {
    var _results;
    if (level.commands.length === 0) {
      return false;
    }
    level.commands = level.commands.slice(0, -1);
    if (level.current_command >= level.commands.length) {
      level.resetAndRun();
      _results = [];
      while (level.step()) {
        _results.push(true);
      }
      return _results;
    }
  };

  arrowButtonRender = function(ctx) {
    return renderArrow(ctx, this.dir.theta, inner_control_size);
  };

  go_up_button = {
    render: arrowButtonRender,
    dir: UP,
    cmd: up_arrow_cmd,
    action: addCommandButtonAction
  };

  go_left_button = {
    render: arrowButtonRender,
    dir: LEFT,
    cmd: left_arrow_cmd,
    action: addCommandButtonAction
  };

  go_right_button = {
    render: arrowButtonRender,
    dir: RIGHT,
    cmd: right_arrow_cmd,
    action: addCommandButtonAction
  };

  go_down_button = {
    render: arrowButtonRender,
    dir: DOWN,
    cmd: down_arrow_cmd,
    action: addCommandButtonAction
  };

  play_button = {
    render: renderPlayButton,
    action: playButtonAction
  };

  undo_button = {
    render: renderUndoButton,
    action: undoButtonAction
  };

  levelMode = {
    STOPPED: 1,
    PLAYING: 2
  };

  levelAnimMode = {
    READY: 1,
    MOVING: 3,
    DONE: 4
  };

  resetLevel = function() {
    this.bot.showxi = this.bot.xi = this.initial_bot_location.xi;
    this.bot.showyi = this.bot.yi = this.initial_bot_location.yi;
    this.bot.showdir = this.bot.dir = this.initial_bot_location.dir;
    this.current_command = 0;
  };

  resetAndRunLevel = function() {
    this.reset();
    this.mode = levelMode.PLAYING;
    this.last_t = Date.now() / 1000;
    this.animation_mode = levelAnimMode.READY;
    delete this.move_control;
  };

  lerp = function(t, x0, x1) {
    if (t < 0) {
      t = 0;
    }
    if (t > 1) {
      t = 1;
    }
    return (x1 - x0) * t + x0;
  };

  animateLevel = function(t) {
    var dt, next_move_control, rel_t;
    if (this.mode === levelMode.STOPPED || (this.mode === levelMode.PLAYING && this.animation_mode === levelAnimMode.READY)) {
      this.show_current_command = this.current_command;
      this.bot.showxi = this.bot.xi;
      this.bot.showyi = this.bot.yi;
      this.bot.showdir = this.bot.dir;
    }
    if (this.mode === levelMode.STOPPED) {
      return;
    }
    dt = t - this.last_t;
    if (this.animation_mode === levelAnimMode.READY) {
      this.show_current_command = this.current_command;
      next_move_control = {
        start: {
          t: t,
          x: this.bot.xi,
          y: this.bot.yi,
          dir: this.bot.dir
        },
        duration: 1 / bot_speed
      };
      if (this.step()) {
        this.move_control = next_move_control;
        this.animation_mode = levelAnimMode.MOVING;
      }
    }
    if (this.animation_mode === levelAnimMode.MOVING) {
      rel_t = (t - this.move_control.start.t) / this.move_control.duration;
      this.bot.showxi = lerp(rel_t, this.move_control.start.x, this.bot.xi);
      this.bot.showyi = lerp(rel_t, this.move_control.start.y, this.bot.yi);
      this.bot.showdir = this.bot.dir;
      if (rel_t >= 1) {
        this.animation_mode = levelAnimMode.READY;
      }
    }
    this.last_t = t;
  };

  stepLevelSimulation = function() {
    if (this.current_command !== null && this.current_command < this.commands.length) {
      this.commands[this.current_command].action(this);
      this.advanceCurrentCommand();
      return true;
    } else {
      return false;
    }
  };

  setupLevel = function(initial_bot_location) {
    var o;
    o = {
      initial_bot_location: initial_bot_location,
      bot: {
        render: renderBot
      },
      commands: [],
      current_command: 0,
      render: renderLevel,
      animate: animateLevel,
      step: stepLevelSimulation,
      mode: levelMode.PLAYING,
      animation_mode: levelAnimMode.READY,
      advanceCurrentCommand: function() {
        return this.current_command++;
      },
      reset: resetLevel,
      resetAndRun: resetAndRunLevel
    };
    o.reset();
    return o;
  };

  setupControlPanel = function() {
    return {
      buttons: [play_button, undo_button, go_up_button, go_down_button, go_left_button, go_right_button],
      selected_button: null,
      render: renderControlPanel,
      click: clickControlPanel
    };
  };

  control_panel = setupControlPanel();

  level_state = setupLevel({
    xi: 0,
    yi: 5,
    dir: 0
  });

  stop = false;

  render = function() {
    var t;
    t = Date.now() / 1000;
    clear(level_cnv, level_ctx);
    clear(prog_cnv, prog_ctx);
    level_state.animate(t);
    level_state.render(level_ctx, prog_ctx);
    if (!stop) {
      return requestAnimationFrame(render);
    }
  };

  requestAnimationFrame(render);

  cont_cnv.addEventListener('click', function(ev) {
    var button, index, pos, _ref;
    pos = getCursorPosition(cont_cnv, ev);
    _ref = control_panel.click(pos), button = _ref[0], index = _ref[1];
    if (button) {
      return button.action(level_state);
    }
  });

  clear(cont_cnv, cont_ctx);

  control_panel.render(cont_ctx);

}).call(this);

//# sourceMappingURL=obot.map
